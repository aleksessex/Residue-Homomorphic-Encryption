# Implementation of the DGK public-key cryptosystem
# This implementation is for demonstration purposes and 

import json, sys, time, itertools, os
from collections import namedtuple
import gmpy2
from gmpy2 import mpz
from functools import reduce

PublicKey = namedtuple('PublicKey', 'n l s g h QRRunOffset QRRunLength')
PrivateKey = namedtuple('PrivateKey', 'p u')

# Precomputed list of successive powers of h for faster encryption
hpow = []

# Precomputed list g^m for faster encryption
gm = []

# Precomputed list of quadratic residuosity of message m modulo s
qrm = []

# Precomputed dictionary of log_m(g^m) for faster decryption
# Keys are group elements g^m; values are m.
# Keys are truncated to  save memory
loggm = {}

# Return a random integer between 2 and x-1
def rand2(x):
	return gmpy2.mpz_random(randomState, x-2)+2

# Return a random integer between 1 and x-1
def rand1(x):
	return gmpy2.mpz_random(randomState, x-1)+1

# Return a random integer between 0 and x-1
def rand0(x):
	return gmpy2.mpz_random(randomState, x)

def randBit():
	return gmpy2.mpz_random(randomState, 2)

def randBits(n):
	return gmpy2.mpz_random(randomState, 2**n)

def base16toMPZ(s):
	return mpz(s,16)

def base62toMPZ(s):
	return mpz(s,62)

# Compute a random value in the cyclic group generated by h
def randh():
	x=1
	for i in xrange(0,pub.l):
		if gmpy2.mpz_random(randomState, 2) != 0:
			x = x * hpow[i] % pub.n
	return x

# Precompute powers of h for faster encryption
def encPrecomp():
	hpow.append(pub.h)
	[hpow.append(hpow[k-1] * hpow[k-1] % pub.n) for k in range(1, pub.l)]

# Precompute g^m for faster encryption
def messagePrecomp():
	if gmpy2.bit_length(pub.s) > 20:
		print "Message space is too large to efficiently store as a precomputation in memory"
		sys.exit()
	gm.append(1)
	[gm.append(gm[k-1] * pub.g % pub.n) for k in range(1, pub.s)]

	# Append False if m is a QR modulo s, otherwise append True
	qrm.append(False)
	[qrm.append(False) if gmpy2.powmod(k,(pub.s-1)/2, pub.s) == 1 else qrm.append(True) for k in range(1, pub.s)]

# Precompute log_m(g^um) for faster decryption
def logGPrecomp():
	for i in xrange(0,pub.s):
		loggm[str(gmpy2.t_mod(gmpy2.powmod(gm[i], (prv.u % pub.s), prv.p), 2 ** 100))] = i

# Return random_state object initialized from b bytes taken from /dev/random
def initRNG(b):
	try:
		a = os.urandom(b)
		return gmpy2.random_state(int(a.encode('hex'), 16))
	except:
		print "Problem initializing PRNG"
		sys.exit()

def loadPubKey(pubKeyFile):
	global pub 
	try:
		with open(pubKeyFile) as fn:
			pubKey = json.load(fn)
	except:
		print "Public key file could not be read"
		sys.exit()
		
	try:	
		n = mpz(pubKey['n'])
		l = mpz(pubKey['l'])
		s = mpz(pubKey['s'])
		g = mpz(pubKey['g'])
		h = mpz(pubKey['h'])
	except:
		print "Public key parameters missing"
		sys.exit()

	if not (gmpy2.is_prime(s)):
		print "Message space s is not prime"
		sys.exit()

	if not (gmpy2.powmod(g,s,n) == 1):
		print "Generator g does not have order s"
		sys.exit()		

	# Load QR threshold function params if defined
	try:
		QRRunOffset = mpz(pubKey['QRRunOffset'])
		QRRunLength = mpz(pubKey['QRRunLength'])
	except:
		QRRunOffset = 0
		QRRunLength = 0

	pub = PublicKey._make([n, l, s, g, h, QRRunOffset, QRRunLength])
	messagePrecomp()
	encPrecomp()
	# print "Public key loaded"

def loadPrvKey(prvKeyfile):
	global prv
	try:
		with open(prvKeyfile) as fn:
			prvKey = json.load(fn)
	except:
		print "Public key file could not be read"
		sys.exit()

	try:
		p = mpz(prvKey['p'])
		u = mpz(prvKey['u'])
	except:
		print "Private key parameters missing"
		sys.exit()

	if not (gmpy2.is_prime(p) and gmpy2.is_prime(pub.n/p)):
		print "p or q not prime"
		sys.exit()

	if not (gmpy2.powmod(pub.h,u,p) == 1):
		print "Generator h has wrong order modulo p"
		sys.exit()

	prv = PrivateKey._make([p, u])
	logGPrecomp()
	# print "Private key loaded"

	return [p, u]

# Encrypt message (Plain DGK)
def encrypt(m):
	# Encryption computing h^r using lookup table
	return gm[m % pub.s] * randh() % pub.n

# Returns the encryption of 0
def encryptOne():
	return gm[1] * randh() % pub.n

# Returns the encryption of 0
def encryptZero():
	return randh()

# Encrypts using restricted-domain message plus offset, implementing the QR threshold function in Z^*_s beginning at QRRunOffset
def encryptQR(m):
	# Encryption computing h^r using lookup table
	if pub.QRRunLength > 0 and pub.QRRunLength > 0:
		return gm[gmpy2.t_mod(m, 2*pub.QRRunLength) + pub.QRRunOffset] * randh() % pub.n

	print "QR threshold functionality add-on not defined in public key"
	sys.exit()

# Decrypt (Plain DGK)
def decrypt(c):
	# Apply private exponent to elimitate G_h subgroup to recover g^{mu}
	mc = gmpy2.powmod(c, prv.u, prv.p)

	# Look up log_m(mc)*(u^-1) mod s to recover m
	return loggm[str(gmpy2.t_mod(mc, 2 ** 100))]

# Decrypt and return the quadratic residuosity of the plaintext in Z^*_s
def decryptQR(c):
	return qrm[decrypt(c)]

# Homomorphically sum two encrypted plaintexts c1, c2
def hadd(c1,c2):
	return c1 * c2 % pub.n

# Homomorphically increment encrypted plaintext c by integer x
def hinc(c,x):
	return c * gm[x] % pub.n

# Homomorphically sum list of encrypted plaintexts c1, c2, ... ck
def haddList(ctList):
	return reduce(lambda x, y: x*y % pub.n, ctList)

# Accepts c, an encryption of a plaintext m in the range 0..QRRunLength and returns a blinded, re-randomized ciphertext evaluating function (m>t)
def thresholdEval(c,t):
	return rerandQR(hinc(c, pub.QRRunOffset + (pub.QRRunLength - t)))

# Homomorphically multiply encrypted plaintext c1 with scalar m
def hmult(c1,m):
	return gmpy2.powmod(c1, m, pub.n)

# Rerandomize ciphertext
def rerand(c):
	return c * encrypt(0) % pub.n

# Rerandomize ciphertext and blind plaintext (preserving quadratic residuosity)
def rerandQR(c):
	r = rand1(pub.s) ** 2 % pub.s
	return gmpy2.powmod(c, r, pub.n) * encrypt(0) % pub.n

# Performs encryption/decryption benchmarks
def bench():
	start_time = time.time()
	for i in xrange(1,1000):
		x = encryptQR(i)
		#x = gmpy2.powmod(i, rand1(2**256), pub.n)
	end_time = time.time()
	print "Time to encrypt (ms): " + str(end_time - start_time)

	start_time = time.time()
	for i in xrange(1,1000):
		x = rerandQR(i)
		#x = gmpy2.powmod(i, rand1(2**256), pub.n)
	end_time = time.time()
	print "Time to rerandomize (ms): " + str(end_time - start_time)

	a=encrypt(rand0(pub.s))
	start_time = time.time()
	for i in xrange(1,1000):
		x = decryptQR(a)
		#x = gmpy2.powmod(i, 2**256, pub.n)
	end_time = time.time()
	print "Time to decrypt (ms): " + str(end_time - start_time)

def init(pubKeyFile, prvKeyFile = None):
	global randomState
	randomState = initRNG(16)
	loadPubKey(pubKeyFile)
	if prvKeyFile is not None:
		loadPrvKey(prvKeyFile)

# Code for testing
# init(sys.argv[1], sys.argv[2])
# bench()